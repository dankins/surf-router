<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="surf-route.html">

<polymer-element name="surf-router" on-route-change="handleRouteChange">
    <template>
    </template>
    <script>
        Polymer({
            publish: {
                /**
                 *
                 */
                routes: undefined
            },
            ready: function(){
                window.onpopstate = this.handlePopstate.bind(this);
            },
            routesChanged: function(){
                window.xRoute = {
                    root: this,
                    ready: false,
                    routes: {},
                    urls: {},
                    current: {},
                    history: []
                };
                this.process(this.routes,this,undefined,{}).then(function(response){
                    // now that all of the routes are ready, process the URL route
                    window.xRoute.ready = true;
                    window.xRoute.tree = response;
                    this.initialURL();

                }.bind(this));
            },
            initialURL: function(){
                var tree = window.xRoute.tree;
                var html5Mode = window.xRoute.root.url !== "#";
                var url = html5Mode ? window.location.pathname : window.location.hash.substring(1,window.location.hash.length);
                var result = this.urlToState(tree,url);
                this.$.root.route(result, url,"activate").then(function(response){
                    this.pushState(url,result,response,true);
                }.bind(this));

            },
            /**
             *
             * @param route - an object containing the properties for the new route
             * @param parent - an HTML for a surf-route
             * @param state
             * @param inTree
             */
            process: function(route,parent,state){
                var tree = {};
                var deferred = Q.defer();
                // push  state->url map
                var elem = new SurfRoute();
                elem.fromObject(state,route,parent.fullURL,parent.fullState).then(function(response){

                    if(parent.nodeName === "SURF-ROUTER"){
                        elem.setAttribute("id","root");
                        this.$.root = elem;
                        parent.shadowRoot.appendChild(elem);
                    } else {
                        window.xRoute.routes[elem.fullState] = elem;
                        parent.addRoute(elem);
                    }
                    tree.url = elem.url;
                    tree.fullURL = elem.fullURL;
                    tree.fullState = elem.fullState;
                    tree.state = elem.state;

                    // Process children
                    var childrenPromises = [];
                    for(var prop in route.children){
                        if (route.children.hasOwnProperty(prop)){
                            var child = route.children[prop];
                            var promise = this.process(child,elem,prop);
                            childrenPromises.push(promise);
                        }
                    }

                    // wait for all the children to resolve then resolve the current one
                    Q.all(childrenPromises).then(function(children){
                        tree.childStates = children;
                        deferred.resolve(tree);
                    });
                }.bind(this));

                return deferred.promise;

            },
            getFullState: function(){
                var baseState = parent.fullState == undefined ? "" : (parent.fullState == "" ? "" : parent.fullState + ".");
                var baseURL = parent.fullURL == undefined ? "" : parent.fullURL;
                elem.fullState = baseState + (elem.state == undefined ? "" : elem.state);
                elem.fullURL = baseURL + elem.url;
                if(state !== undefined){
                    window.xRoute.routes[elem.fullState] = {
                        fullState: elem.fullState,
                        elem: elem,
                        url: elem.fullURL
                    };
                }
            },
            handleRouteChange: function(e){
                if(e.detail.state === "<"){
                    history.back();
                    if(e.detail.message !== undefined){
                        this.fire("route-message",e.detail.message);
                    }
                } else {
                    var state = e.detail.state;
                    var url = e.detail.url === undefined ? "" : e.detail.url;
                    var message = e.detail.message;
                    var data = e.detail.data == undefined ? {} : e.detail.data;
                    console.log("ROUTE:", state, e.detail.data);

                    this.$.root.route(state, url,"activate",data).then(function(response){
                        this.pushState(e.detail.url, e.detail.state,response);
                        console.log("ROUTE COMPLETE:", state, url, response);
                        if(message !== undefined){
                            this.$.toast.text = message;
                            this.$.toast.show();
                        }

                    }.bind(this)).done();
                }

            },
            pushState: function(url,state,data,replace){
                var push = { data: data, state: state, url: url  };
                window.xRoute.current = push;
                xRoute.history.push(push);
                if(replace){
                    history.replaceState(push,undefined,url);
                } else {
                    history.pushState(push,undefined,url);
                }
            },
            handlePopstate: function(e){
                xRoute.history.pop();
                if(e.state == undefined){
                    this.initialURL();
                } else {
                    //var url = e.state.url.substring(this.$.root.url.length+1,e.state.url.length);
                    this.$.root.route(e.state.state, e.state.url,"activate");
                }
            },
            stateToUrl: function(routes,state){

            },
            urlToState: function(routes,url){
                var idx = url.indexOf("/",1);
                var segment = idx > 0 ? url.substring(0,idx) : url;
                var urlRemaining = idx > 0 ? url.substring(idx,url.length) : "";

                if(routes.childStates.length > 0 && segment !== undefined) {
                    var result = routes.childStates.reduce(function(acc,child){
                        if(child.url.substring(0,2) == ("/:") && segment.substring(0,1) === "/") {
                            acc.dynamic = child;
                        } else if(child.url === segment) {
                            acc.exact = child;
                        } else if(child.url === "") {
                            acc.default = child;
                        }
                        return acc;
                    },{});


                    var selected = undefined;
                    if(result.exact !== undefined){
                        selected = result.exact
                    }  else if(result.dynamic !== undefined){
                        selected = result.dynamic;
                    } else if(result.default !== undefined){
                        selected = result.default;
                        // we didn't actually consume this part of the URL, so put it back on
                        urlRemaining = urlRemaining === undefined ? segment : segment + urlRemaining;
                    } else {
                        return routes.fullState;
                    }
                    return this.urlToState(selected,urlRemaining);
                } else {
                    return routes.fullState;
                }

            }
        })
    </script>
</polymer-element>