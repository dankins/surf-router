<polymer-element name="route-link">
<template>
    <a href="{{href}}" on-click="{{fireChange}}"><content></content></a>
</template>
<script>
Polymer({
    publish: {
        url: undefined,
        state: undefined,
        relative: false,
        dataWatcher: {},
        data: {}
    },
    attached: function(){
        this.data = this.bootstrapData();
        this.setupMutationObserver();
    },
    stateChanged: function(old,newVal){
        // it is possible that a route-link may be created before the routing tree is ready
        // if this is the case, then set up an observe that will wait until the tree is ready
        if(! xRoute.ready){
            var observer = new PathObserver(xRoute,'ready');
            observer.open(function(){
                this.processState(this.state);
                observer.close();
            }.bind(this));
        } else {
            var result = this.processState(this.state);
            this.processed = result.state;
        }
        // attach an observer that will fire whenever the current route is changed

    },
    setupCurrentStateObserver: function(callback){
        if(this.currentStateObserver == undefined){
            this.currentStateObserver = new PathObserver(xRoute,'current');
            this.currentStateObserver.open(callback.bind(this));
        }
    },
    currentStateChanged: function(added,removed,changed){
        console.log("current changed",added,removed,changed);
    },
    processState: function(state){
        var relative = false;
        var output;
        if(state == "<"){
            console.log(xRoute.history);
            relative = true;
            this.setupCurrentStateObserver(this.backStateProcess.bind(this,this.state));
        }
        else if(state.indexOf("^") >= 0){
            relative = true;
            console.log(window.xRoute.current);
            this.setupCurrentStateObserver(this.relativeStateProcess.bind(this,this.state));
        }
        else if(state.substring(0,1) === "."){
            relative = true;
            output = window.xRoute.current.state + state.substring(1,state.length);
        } else {
            output = state;
            //this.processed = state;
            this.url = window.xRoute.routes[output].fullURL;
        }

        return {
            state: output,
            url: this.url
        };

    },
    relativeStateProcess: function(input,cur){
        // current: main.queue.list
        // input: ^.edit
        console.log("CHANGE",input,cur);
        var workingState = cur.state.split(".");
        var segments = input.split(".");
        segments.forEach(function(segment){
            // if there is a ^ we need to pop the last state
            if(segment == "^"){
                workingState.pop();
            } else {
                workingState.push(segment);
            }
        });

        var complete = workingState.join(".");
        this.data = cur.data;
        this.processed = complete;
        console.log("PROCESSED:",complete,cur.data);
        this.url = window.xRoute.routes[complete].fullURL;
    },
    backStateProcess: function(input,cur){
        console.log("BACK CHANGE",xRoute.history);
        var state = "";
        if(xRoute.history.length == 1){
            console.log("BACK CHANGE REL",xRoute.history[0]);
            this.relativeStateProcess("^",xRoute.history[0]);
        } else {
            state = xRoute.history[xRoute.history.length -2].state;
            this.processed = state;
            console.log("PROCESSED:",xRoute.history[xRoute.history.length -2].url);
            //this.href = xRoute.history[xRoute.history.length -2].url;
        }
    },
    urlChanged: function (){
        //this.replaceData();
        var res = this.getSegments(this.url,this.data);
        this.segments = res.segments;
        this.segmentMap = res.segmentMap;

        this.concatURL();
    },
    getSegments: function(url,data){
        // this is just a shortcut if there are no dynamic bits
        if(url.indexOf(":") < 0){
            return { segments: [this.url], segmentMap: {} };
        }
        //var replaceSegment = this.replaceSegment.bind(this);

        return url.split("/").reduce(function(acc,cur){
            if(cur.substring(0,1) === ":"){
                acc.idx += 1;
                var name = cur.substring(1,cur.length);
                var dataVal = data[name];
                //var attr = this.getAttribute("data-"+name);

                if(dataVal === undefined || dataVal === null) {
                    console.log("Expecting to find attribute with name data-"+ name + " on route link");
                }

                acc.segments[acc.idx] = {
                    data: dataVal,
                    name: name
                };
                acc.segmentMap[name] = acc.idx;

                return {
                    idx: acc.idx+1,
                    segments: acc.segments,
                    segmentMap: acc.segmentMap
                }
            } else {
                var prev = acc.segments[acc.idx] === undefined ? "" : acc.segments[acc.idx];
                acc.segments[acc.idx] = cur === "" ? prev : prev + "/"+cur;
                return {
                    idx: acc.idx,
                    segments: acc.segments,
                    segmentMap: acc.segmentMap
                }
            }
        }.bind(this),{
            idx: 0,
            segments: [],
            segmentMap: {}
        });
    },
    replaceSegment: function(key){
        console.log("REPLACE:",key,this.data[key],this.segments);
        var idx = this.segmentMap[key];
        this.segments[idx].data = this.data[key];
        this.concatURL();
    },
    concatURL: function(){
        this.href = this.segments.reduce(function(acc,cur){
            if(cur.name !== undefined){
                return acc  + "/" + cur.data;
            } else {
                return acc + cur;
            }
        },"");
    },
    bootstrapData: function(){
        var data = {};
        for (var i = 0, attrs = this.attributes, n = attrs.length; i < n; i++){
            var name = attrs[i].nodeName;
            if(name.substring(0,5) === "data-"){
                name = name.substring(5);
                data[name] = attrs[i].value;
            }
        }
        return data;
    },
    setupMutationObserver: function(){
        this.observer = new MutationObserver(this.mutationCallback.bind(this));
        var config = { attributes: true, childList: false, characterData: false };
        this.observer.observe(this, config);
    },
    mutationCallback: function(mutations) {
        var d = this.data;
        var target = this;
        mutations.forEach(function(mutation) {
            if(mutation.attributeName.substring(0,5) === "data-"){
                var stub = mutation.attributeName.substring(5);
                console.log("CHANGE");
                d[stub] = target.getAttribute(mutation.attributeName);
                target.replaceSegment(stub);
            }
        });
    },
    fireChange: function(e) {
        if (e != undefined) {
            e.preventDefault();
        }
        console.log(this.href,this.state);
        if(this.state === "<"){
            window.history.go(-1);
        } else if (this.state === ">"){
            window.history.go(1);
        } else {
            this.fire("route-change", {state: this.processed, url: this.href, relState: this.state});
        }


    }
});
</script>
</polymer-element>